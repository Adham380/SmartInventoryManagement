<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inventory Management</title>
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
    <link href="./stylesheets/style.css" rel="stylesheet">
</head>

<body>

<div class="container mt-4">

    <h1>Inventory Management</h1>

    <!-- Add New Item Form -->
    <form id="addItemForm" action="/addNewItem" method="post">
        <div class="form-group">
            <label for="inputMethod">Enter Item By:</label>
            <select class="form-control" id="inputMethod" name="inputMethod" onchange="updateInputFields()">
                <option value="barcode">Barcode</option>
                <option value="productName" selected>Product Name</option>
                <!-- Additional methods can be added here in the future -->
            </select>
        </div>
        <div class="form-group" id="inputFieldDiv">
            <input type="text" class="form-control" id="inputField" name="inputField" required>
        </div>

        <div class="form-group">
            <button type="button" id="startScan" class="btn btn-primary">Start Scanning</button>
            <div id="scanner-container" style="display: none"></div>
        </div>

        <button id="addItemButton" type="submit" class="btn btn-primary">Add Item</button>
    </form>

    <div class="d-flex mt-4 justify-content-between align-items-center" style="flex-wrap: wrap">
        <input type="text" id="searchBar" class="form-control w-50" placeholder="Search items..." onkeyup="filterItems()">
<!--        sort-->
        <div>
            <label for="sort">Sort by:</label>
            <select id="sort" onchange="sortItems()">
                <option value="dateAdded">Date Added</option>
                <option value="name">Name</option>
                <option value="count">Count</option>
                <option value="aisle">Aisle</option>
            </select>
        </div>
        <div>
            <button class="btn btn-primary" onclick="selectAll()">Select All</button>
            <button class="btn btn-primary" onclick="deselectAll()">Deselect All</button>
        </div>
    </div>

    <!-- Inventory Grid -->
    <div class="row mt-4" id="inventoryGrid">
        <!-- Inventory items will be populated here -->
    </div>
    <div class="mt-4">
        <div class="d-flex justify-content-between align-items-center">
            <div>
                <label>Items per page:</label>
                <select id="itemsPerPage" onchange="updateItemsPerPage()">
                    <option value="4">4</option>
                    <option value="8" selected>8</option>
                    <option value="12">12</option>
                    <option value="16">16</option>
                </select>
            </div>
            <nav>
                <ul class="pagination">
                    <div style="display: flex; flex-direction: row; align-items: center; gap: 0.2vw; margin-right: 1vw">
                    <input style="width: 5vw" type="number" id="currentPage" value="1" onchange="changePage()">
                    <div>of</div>
                    <div id="totalPages"></div>
                    </div>
                    <li class="page-item"><a class="page-link" href="javascript:previousPage()">Previous</a></li>
                    <!-- Page numbers can be generated here -->
                    <div id="pageNumbers"></div>
                    <li class="page-item"><a class="page-link" href="javascript:nextPage()">Next</a></li>
                </ul>
            </nav>
        </div>
    </div>

    <!-- Recipe Finder Form -->
    <form id="recipeFinderForm" class="mt-4">
        <h3>Find Recipe</h3>
        <div class="form-group">
            <label for="diet">Diet:</label>
            <select style="margin-bottom: 0.2vh" class="form-control" id="diet" name="diet">
                <option value="">Any</option>
                <option value="vegan">Vegan</option>
                <option value="vegetarian">Vegetarian</option>
                <option value="glutenFree">Gluten Free</option>
                <!-- Add more diet options as needed -->
            </select>
<!--            number of recipes-->
        <label style="margin-top: 1vh" for="number">Number of Recipes:</label>
        <input type="number" id="number" name="number" min="1" max="10" value="5">
        </div>

        <div class="form-group">
            <label for="searchMethod">Search Method:</label>
            <select class="form-control" id="searchMethod" name="searchMethod">
                <option value="simple">Simple</option>
                <option value="complex">Complex</option>
            </select>
        </div>
        <!--        Add checkboxes for intolerances, available equipment and to choose max ready time-->
        <div id="complexSearchContainer" style="display: none">
            <!-- Additional parameters for complex search can be added here -->
            <!--        Dropdown simple/complex search-->
            <div class="form-group">
                <label for="intolerances">Intolerances:</label>
                <div id="intolerances">
                    <input type="checkbox" name="intolerances" value="dairy"> Dairy<br>
                    <input type="checkbox" name="intolerances" value="egg"> Egg<br>
                    <input type="checkbox" name="intolerances" value="gluten"> Gluten<br>
                    <input type="checkbox" name="intolerances" value="grain"> Grain<br>
                    <input type="checkbox" name="intolerances" value="peanut"> Peanut<br>
                    <input type="checkbox" name="intolerances" value="seafood"> Seafood<br>
                    <input type="checkbox" name="intolerances" value="sesame"> Sesame<br>
                    <input type="checkbox" name="intolerances" value="shellfish"> Shellfish<br>
                    <input type="checkbox" name="intolerances" value="soy"> Soy<br>
                    <input type="checkbox" name="intolerances" value="sulfite"> Sulfite<br>
                    <input type="checkbox" name="intolerances" value="tree nut"> Tree Nut<br>
                    <input type="checkbox" name="intolerances" value="wheat"> Wheat<br>
                    <!-- Add more intolerances as needed -->
                </div>
            </div>

            <div class="form-group">
                <label for="availableEquipment">Available Equipment:</label>
                <div id="availableEquipment">
                    <input type="checkbox" name="availableEquipment" value="blender"> Blender<br>
                    <input type="checkbox" name="availableEquipment" value="grill"> Grill<br>
                    <input type="checkbox" name="availableEquipment" value="oven"> Oven<br>
                    <input type="checkbox" name="availableEquipment" value="microwave"> Microwave<br>
                    <input type="checkbox" name="availableEquipment" value="toaster"> Toaster<br>
                    <input type="checkbox" name="availableEquipment" value="stove"> Stove<br>
                    <!-- Add more equipment as needed -->
                </div>
            </div>

            <div class="form-group">
                <label for="maxReadyTime">Max Ready Time (minutes):</label>
                <input type="number" id="maxReadyTime" name="maxReadyTime" min="1" max="240" value="60">
            </div>
        </div>
        <button type="submit" class="btn btn-primary">Find Recipe</button>

    </form>
<!--    Show recent recipes with button-->
    <h3 style="margin-top: 2vh">Recent Recipes</h3>
    <button class="btn btn-primary" onclick="showRecentRecipes()">Show Recent Recipes</button>
    <div class="row mt-4" id="recentRecipes">
        <!-- Recent recipes will be populated here -->
    </div>

    <div class="row mt-4" id="recipesSection">
        <!-- Recipes will be populated here -->
    </div>
    <div class="modal fade" id="recipeModal" tabindex="-1" aria-labelledby="recipeModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modalContainer">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="recipeModalLabel">Recipe Details</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body" id="recipeModalBody">
                    <!-- Recipe details will be populated here -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@ericblade/quagga2/dist/quagga.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qr-scanner/1.4.2/qr-scanner.min.js" integrity="sha512-Fb3L5w+k6OMng6v8gWYr7fuO//kwaC0PfMReI2pYIRYHRfkjvrsNHoGkiVCvjNkrXX3+Ve9Ag+COx98AZlvR7w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qr-scanner/1.4.2/qr-scanner-worker.min.js" integrity="sha512-U6MqJWVLYAju7u3JtHVasPpguvjKzKt44x4t4txuRLaJTVuNdYNCQFrevlxKCkQm1eEdHa3gZBoOZwau4MGPZQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qr-scanner/1.4.2/qr-scanner.legacy.min.js" integrity="sha512-p8m79Tn59dsKFUelNkaMId11T6xaD6sIjtuHYduah5b97nLHBRItTDlibAQ1mVoaS3zRxbLewQEXLoJI8PRjBQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qr-scanner/1.4.2/qr-scanner.umd.min.js" integrity="sha512-a/IwksuXdv0Q60tVkQpwMk5qY+6cJ0FJgi33lrrIddoFItTRiRfSdU1qogP3uYjgHfrGY7+AC+4LU4J+b9HcgQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qr-scanner/1.4.2/types/qr-scanner.d.ts"></script>
<script>
    if(localStorage.getItem("searchMethod") === "complex"){
        document.getElementById('complexSearchContainer').style.display = 'block';
        document.getElementById('searchMethod').value = 'complex';
    } else {
        document.getElementById('complexSearchContainer').style.display = 'none';
        document.getElementById('searchMethod').value = 'simple';
    }
<!--    Check if intolerances, available equipment and  max ready time exist locally, if so, set them-->
if(localStorage.getItem('intolerances')){
    const intolerances = localStorage.getItem('intolerances').split(',');
    intolerances.forEach(intolerance => {
        document.querySelector(`#intolerances input[value="${intolerance}"]`).checked = true;
    });
}
if(localStorage.getItem('availableEquipment')){
    const availableEquipment = localStorage.getItem('availableEquipment').split(',');
    availableEquipment.forEach(equipment => {
        document.querySelector(`#availableEquipment input[value="${equipment}"]`).checked = true;
    });
}
if(localStorage.getItem('maxReadyTime')){
    document.getElementById('maxReadyTime').value = localStorage.getItem('maxReadyTime');
}
const searchMethodDropdown = document.getElementById('searchMethod');
    searchMethodDropdown.addEventListener('change', () => {
        const complexSearchContainer = document.getElementById('complexSearchContainer');
        if(searchMethodDropdown.value === 'complex') {
            complexSearchContainer.style.display = 'block';
            localStorage.setItem('searchMethod', 'complex');
        } else {
            complexSearchContainer.style.display = 'none';
            localStorage.setItem('searchMethod', 'simple');
        }
    });
    function showRecentRecipes(){
        const recentRecipes = document.getElementById('recentRecipes');
        recentRecipes.innerHTML = '';
        //recipes are in local storage. Get all values that have a number as key
        const keys = Object.keys(localStorage);
        const recentRecipesArray = [];
        keys.forEach(key => {
            console.log(key);
            if(!isNaN(key)){
                console.log(key);
                recentRecipesArray.push(JSON.parse(localStorage.getItem(key)));
            }
        });
        recipeCardsBuilder(recentRecipesArray);
    }
    function sortItems(){
        const inventoryGrid = document.getElementById("inventoryGrid");
        const inventoryItems = inventoryGrid.getElementsByClassName('col-md-3');
        const sortMethod = document.getElementById('sort').value;
        //aisle can be gotten from dataset
        if(sortMethod === 'name'){
            //sort by name
            const sortedItems = Array.from(inventoryItems).sort((a, b) => {
                const aTitle = a.querySelector('.card-title').textContent;
                const bTitle = b.querySelector('.card-title').textContent;
                return aTitle.localeCompare(bTitle);
            });
            inventoryGrid.innerHTML = '';
            sortedItems.forEach(item => {
                inventoryGrid.appendChild(item);
            });
        } else if(sortMethod === 'count'){
            //sort by count
            const sortedItems = Array.from(inventoryItems).sort((a, b) => {
                const aCount = parseInt(a.querySelector('.card-text').textContent.split(' ')[1]);
                const bCount = parseInt(b.querySelector('.card-text').textContent.split(' ')[1]);
                return aCount - bCount;
            });
            inventoryGrid.innerHTML = '';
            sortedItems.forEach(item => {
                inventoryGrid.appendChild(item);
            });
        } else if(sortMethod === 'aisle'){
            //sort by aisle
            console.log('sort by aisle')
            const sortedItems = Array.from(inventoryItems).sort((a, b) => {
                console.log(a.dataset.aisle);
                console.log(b.dataset.aisle);
                const aAisle = a.dataset.aisle;
                const bAisle = b.dataset.aisle;
                return aAisle.localeCompare(bAisle);
            });
            inventoryGrid.innerHTML = '';
            sortedItems.forEach(item => {
                inventoryGrid.appendChild(item);
            });
        } else if (sortMethod === 'dateAdded'){
        //dateAdded is default
            fetchAndDisplayInventory(true)
        }
    }
    function selectAll() {
        const checkboxes = document.querySelectorAll('.itemCheckbox');
        checkboxes.forEach(checkbox => {
            checkbox.checked = true;
        });
    }
    function deselectAll() {
        const checkboxes = document.querySelectorAll('.itemCheckbox');
        checkboxes.forEach(checkbox => {
            checkbox.checked = false;
        });
    }
    function filterItems() {
        // Declare variables
        let input, filter, inventoryGrid, inventoryItems, inventoryItem, i, txtValue;
        input = document.getElementById('searchBar');
        filter = input.value.toUpperCase();
        inventoryGrid = document.getElementById("inventoryGrid");
        inventoryItems = inventoryGrid.getElementsByClassName('col-md-3');

        //use regex to partially match the title
        const regex = new RegExp(filter, 'i');
        // Loop through all list items, and hide those who don't match the search query
        for (i = 0; i < inventoryItems.length; i++) {
            inventoryItem = inventoryItems[i];
            txtValue = inventoryItem.textContent || inventoryItem.innerText;
            if (txtValue.toUpperCase().match(regex)) {
                inventoryItem.style.display = "";
            } else {
                inventoryItem.style.display = "none";
            }
        }
        if(filter === ''){
            renderItems();
        }
    }

    let currentPage = 1;
    let itemsPerPage = 8;

    function changePage() {
        currentPage = document.getElementById('currentPage').value;
        renderItems();
    }
    function updateItemsPerPage() {
        const oldItemsPerPage = itemsPerPage;
        itemsPerPage = parseInt(document.getElementById('itemsPerPage').value);

        // Calculate the index of the first item on the current page
        const firstVisibleItemIndex = (currentPage - 1) * oldItemsPerPage;

        // Recalculate currentPage so that the firstVisibleItemIndex remains visible
        currentPage = Math.ceil((firstVisibleItemIndex + 1) / itemsPerPage);

        renderItems();
    }


    function nextPage() {
        if(currentPage === Math.ceil(document.querySelectorAll('.col-md-3').length / itemsPerPage)) {
            return;
        }
        currentPage++;
        renderItems();
    }

    function previousPage() {
        if(currentPage === 1) {
            return;
        }
        currentPage--;
        renderItems();
    }

    function renderItems() {
        console.log('render items');
        const items = document.querySelectorAll('.col-md-3');
        //make sure that if the current page is not the first, then recalculate the start index and end index and show the appropiate page
        const startIndex = (currentPage - 1) * itemsPerPage;
        const endIndex = startIndex + parseInt(itemsPerPage)
        items.forEach((item, index) => {
            if (index >= startIndex && index < endIndex) {
                item.style.display = 'block';
            } else {
                item.style.display = 'none';
            }
        });
        document.querySelector('#totalPages').textContent = Math.ceil(items.length / itemsPerPage).toString();
        document.querySelector('#currentPage').value = currentPage.toString();
    }
    // ... Additional logic for rendering items based on pagination

    const form = document.getElementById('addItemForm');
    const barcodeInput = document.getElementById('barcode');

    function updateInputFields() {
        const inputMethod = document.getElementById('inputMethod').value;
        const inputFieldDiv = document.getElementById('inputFieldDiv');
        const inputField = document.getElementById('inputField');

        if (inputMethod === 'barcode') {
            inputField.setAttribute('placeholder', 'Enter Barcode');
        } else if (inputMethod === 'productName') {
            inputField.setAttribute('placeholder', 'Enter Product Name');
        }
        // Additional conditions for new methods can be added here in the future
    }

    // Initial call to set the correct placeholder on page load
    updateInputFields();


    form.addEventListener('submit', async (e) => {
        e.preventDefault(); // prevent default form submission behavior

        const inputMethod = document.getElementById('inputMethod').value;
        const inputValue = document.getElementById('inputField').value;

        let endpoint;
        let payload;

        if (inputMethod === 'barcode') {
            endpoint = '/addNewItem';
            payload = { barcode: inputValue };
        } else if (inputMethod === 'productName') {
            endpoint = '/addItemByTitle';
            payload = { title: inputValue, language: 'de' };
        }
        // Additional conditions for new methods can be added here in the future

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });
            console.log(response.status);
            if(response.status === 200) {
                //clear input field
                // success
                await fetchAndDisplayInventory()
            } else {
                // error
                alert('Error adding item!');
            }
            document.getElementById('inputField').value = '';

            // Rest of the submission logic remains the same

        } catch (error) {
            console.error('Error:', error);
        }
    });


    async function fetchAndDisplayInventory(refreshBoolean) {
        try {
            const response = await fetch('/getInventory');
            let inventory = await response.json();
            //filter items that fulfill the condition that the key that is called "id" exists and the value is a number
            inventory = Object.fromEntries(Object.entries(inventory).filter(([key, value]) => isNaN(key)));

            refreshBoolean = refreshBoolean || false;

            const inventoryGrid = document.getElementById('inventoryGrid');
            // inventoryGrid.innerHTML = ''; // Clear previous items

            for (let title in inventory) {
                const item = inventory[title];
                //check if card already exists and count is equal to item.count card-title card-text in card-body
                //get all card bodies and check
                const cardBodies = document.querySelectorAll('.card-body');
                let cardExists = false;
                cardBodies.forEach(cardBody => {
                    if(cardBody.querySelector('.card-title').textContent === title && cardBody.querySelector('.card-text').textContent == `count: ${item.count}`){
                        cardExists = true;
                    } else if (cardBody.querySelector('.card-title').textContent === title && cardBody.querySelector('.card-text').textContent != `count: ${item.count}`){
                        cardExists = true;
                        cardBody.querySelector('.card-text').textContent = `count: ${item.count}`;
                    }
                });
                if(cardExists && !refreshBoolean){
                    continue;
                }
                if(cardExists && refreshBoolean){
                    inventoryGrid.innerHTML = '';
                }

                const itemDiv = document.createElement('div');
                itemDiv.className = 'col-md-3';
                //add aisle as dataset
                itemDiv.dataset.aisle = item.aisle;
                const card = document.createElement('div');
                card.className = 'card mt-2';

                const cardBody = document.createElement('div');
                cardBody.className = 'card-body';

                // Image thumbnail
                const itemImage = document.createElement('img');
                itemImage.className = 'card-img-top';
                if(!item.image.includes('http')){
                itemImage.src = "https://spoonacular.com/cdn/ingredients_500x500/" + item.image;
                } else {
                itemImage.src = item.image;
                }
                itemImage.alt = title;
                card.appendChild(itemImage);

                const titleElement = document.createElement('h5');
                titleElement.className = 'card-title';
                titleElement.textContent = title;
                cardBody.appendChild(titleElement);

                const countElement = document.createElement('p');
                countElement.className = 'card-text';
                countElement.textContent = `count: ${item.count}`;
                cardBody.appendChild(countElement);



                // Checkbox to select the item
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = title;
                checkbox.className = 'itemCheckbox';
                cardBody.appendChild(checkbox);

                const editButton = document.createElement('button');
                editButton.className = 'btn btn-outline-secondary btn-sm edit-button';
                editButton.innerHTML = '<i class="fas fa-pencil-alt"></i>';
                editButton.addEventListener('click', async () => {
                    // Handle the edit action here
                    const newcount = prompt(`Edit count for ${title}`, item.count);
                    if (newcount && !isNaN(newcount)) {
                        console.log('New count:', newcount);
                        item.count = parseInt(newcount);
                        countElement.textContent = `count: ${item.count}`;
                        //update item
                        const response = await fetch('/updateItem', {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                title: title,
                                count: newcount
                            })
                        });

                        await response.json();
                        if(response.status === 200) {
                            // success
                            alert('Item updated successfully!');
                        } else {
                            // error
                            alert('Error updating item!');
                        }
                        // You can also update the JSON/database here if required
                    }
                });
                // Position the button to the top right of the card
                editButton.style.position = 'absolute';
                editButton.style.top = '10px';
                editButton.style.right = '10px';

                card.appendChild(editButton);
                card.appendChild(cardBody);
                itemDiv.appendChild(card);
                inventoryGrid.appendChild(itemDiv);
                renderItems();
            }
        } catch (error) {
            console.error('Error fetching inventory:', error);
        }
    }

    // Call the function to populate the grid on page load
    fetchAndDisplayInventory();
    function getSelectedItems() {
        const checkboxes = document.querySelectorAll('.itemCheckbox:checked');
        const selectedItems = [];

        checkboxes.forEach(checkbox => {
            selectedItems.push(checkbox.value);
        });

        return selectedItems;
    }

    function scrollToBottomOfDiv(id){
        const div = document.getElementById(id);
        const divBottom = div.getBoundingClientRect().bottom;

        // Calculate the necessary scroll position to get the bottom of the div into view
        const scrollPosition = window.scrollY + divBottom - window.innerHeight;

        // Scroll smoothly to the calculated position
        window.scrollTo({
            top: scrollPosition,
            behavior: "smooth"
        });
    }
    const recipeFinderForm = document.getElementById('recipeFinderForm');
    const dietInput = document.getElementById('diet');
    //get diet from local storage and set it as default
    const diet = localStorage.getItem('diet') || '';
    dietInput.selectedIndex = Array.from(dietInput.options).findIndex(option => option.value === diet);
    function recipeCardsBuilder(recipes){
        const recentRecipes = document.getElementById('recentRecipes');
        recentRecipes.innerHTML = '';
        recipes.forEach(recipe => {
            const recipeDiv = document.createElement('div');
            recipeDiv.className = 'col-md-3';

            const card = document.createElement('div');
            card.className = 'card mt-2';

            // Attach the recipe ID to the card as a data attribute for easy retrieval
            card.dataset.recipeId = recipe.id;

            // Image thumbnail
            const recipeImage = document.createElement('img');
            recipeImage.className = 'card-img-top';
            recipeImage.src = recipe.image;
            recipeImage.alt = recipe.title;
            recipeImage.style.cursor = 'pointer';
            recipeImage.addEventListener('click', () => {
                displayRecipeModal(card);
            });
            card.appendChild(recipeImage);

            const cardBody = document.createElement('div');
            cardBody.className = 'card-body';

            const titleElement = document.createElement('h5');
            titleElement.className = 'card-title';
            titleElement.textContent = recipe.title;
            cardBody.appendChild(titleElement);

            // Just showing the title and image for now. Adjust for other data as needed.

            card.appendChild(cardBody);
            recipeDiv.appendChild(card);
            recentRecipes.appendChild(recipeDiv);
        });
        //     scroll down to the bottom of recent recipes
        scrollToBottomOfDiv('recentRecipes');

    }
    //get the selected items and diet and send them to the server to find a recipe with /getRecipe
    recipeFinderForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const searchMethodDropdown = document.getElementById('searchMethod');

        const selectedItems = getSelectedItems();
        const number = document.getElementById('number').value;
        const dietValue = dietInput.value;
        // const intolerances = req.body.intolerances;
        // const availableEquipment = req.body.availableEquipment;
        // const maxReadyTime = req.body.maxReadyTime;
        // If the user has selected the complex search method, then additional parameters can be added here
        const searchMethod = searchMethodDropdown.value;
        // Get selected intolerances as a comma-separated string
        let intolerances = "";
        document.querySelectorAll('#intolerances input[type="checkbox"]:checked').forEach(checkbox => {
            intolerances += checkbox.value + ',';
        });
        intolerances = intolerances.slice(0, -1); // Remove the trailing comma
console.log(intolerances);
// Save intolerances locally
        localStorage.setItem('intolerances', intolerances);

// Get selected equipment as a comma-separated string
        let availableEquipment = "";
        document.querySelectorAll('#availableEquipment input[type="checkbox"]:checked').forEach(checkbox => {
            availableEquipment += checkbox.value + ',';
        });
        availableEquipment = availableEquipment.slice(0, -1); // Remove the trailing comma
        const maxReadyTime = document.getElementById('maxReadyTime').value;
// Save available equipment locally
        localStorage.setItem('availableEquipment', availableEquipment);
console.log(availableEquipment);
        // Store diet value locally to remember preference
        localStorage.setItem('diet', dietValue);
        if(selectedItems.length === 0) {
            //select all items
            const checkboxes = document.querySelectorAll('.itemCheckbox');
            checkboxes.forEach(checkbox => {
                selectedItems.push(checkbox.value);
            });
        }
        try {
            //if search method is simple then send a post request to /getRecipe
            let response = "";
            if(searchMethod === "simple") {
                 response = await fetch('/getRecipe', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        selectedItems: selectedItems,
                        number: number,
                        diet: dietValue
                    })
                });
            } else if(searchMethod === "complex"){
                response = await fetch('/getComplexRecipes', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        selectedItems: selectedItems,
                        number: number,
                        diet: dietValue,
                        intolerances: intolerances,
                        availableEquipment: availableEquipment,
                        maxReadyTime: maxReadyTime
                    })
                });
            }

            const recipes = await response.json();

            if(response.status === 200) {
                // success

                const recipesSection = document.getElementById('recipesSection');
                recipesSection.innerHTML = '';  // Clear previous recipes

                recipes.forEach(recipe => {
                    const recipeDiv = document.createElement('div');
                    recipeDiv.className = 'col-md-3';

                    const card = document.createElement('div');
                    card.className = 'card mt-2';

                    // Attach the recipe ID to the card as a data attribute for easy retrieval
                    card.dataset.recipeId = recipe.id;

                    // Image thumbnail
                    const recipeImage = document.createElement('img');
                    recipeImage.className = 'card-img-top';
                    recipeImage.src = recipe.image;
                    recipeImage.alt = recipe.title;
                    recipeImage.style.cursor = 'pointer';
                    recipeImage.addEventListener('click', () => {
                        displayRecipeModal(card);
                    });
                    card.appendChild(recipeImage);

                    const cardBody = document.createElement('div');
                    cardBody.className = 'card-body';

                    const titleElement = document.createElement('h5');
                    titleElement.className = 'card-title';
                    titleElement.textContent = recipe.title;
                    cardBody.appendChild(titleElement);

                    // Just showing the title and image for now. Adjust for other data as needed.

                    card.appendChild(cardBody);
                    recipeDiv.appendChild(card);
                    recipesSection.appendChild(recipeDiv);
                });
            //     scroll down to recipes
                scrollToBottomOfDiv('recipesSection');
            } else {
                // error
                alert('Error finding recipes!');
            }

        } catch (error) {
            console.error('Error:', error);
        }
    });

    async function displayRecipeModal(card) {
        const modalBody = document.getElementById('recipeModalBody');
        modalBody.innerHTML = ''; // Clear previous recipe details

        const recipeId = card.dataset.recipeId;

        let recipeDetails = []
        let recipeCard = ""
        // Check if the recipe is saved locally
        if(localStorage.getItem(recipeId)){
            recipeDetails = JSON.parse(localStorage.getItem(recipeId));
        } else {
            // const response = await fetch(`/getRecipeDetails/${recipeId}`);
            //add language to parameters
            const response = await fetch(`/getRecipeDetails/${recipeId}?language=de`);

            recipeDetails = await response.json();

            if (response.status === 200) {
                localStorage.setItem(recipeId, JSON.stringify(recipeDetails));
            } else {
                alert('Error finding recipe details!');
                return;
            }
        }
        // Check if recipeCard is saved locally. key is "card+id"
        const cardId = 'card' + recipeId;
        if(localStorage.getItem(cardId)){
            recipeCard = JSON.parse(localStorage.getItem(cardId));
        } else {
            //get the recipe card per rest api
            const response = await fetch(`/getRecipeCard/${recipeId}?language=de`);
            recipeCard = await response.json();
            console.log(recipeCard);
            if(recipeCard.status === "success"){
                localStorage.setItem(cardId, JSON.stringify(recipeCard));
            } else {
                alert('Error finding recipe card!');
                return;
            }
        }


        // const titleElement = document.createElement('h3');
        // titleElement.textContent = recipeDetails.title;
        // titleElement.style.textAlign = 'center';
        // modalBody.appendChild(titleElement);
        const recipeBody = document.createElement('div');
        recipeBody.className = 'recipe-card-body';
        modalBody.appendChild(recipeBody);
        const recipeImage = document.createElement('img');
        recipeImage.style.width = '55%';
        //cut off bottom 10% of image
        // recipeImage.src = recipeDetails.image;
        recipeImage.src = recipeCard.url;
        recipeImage.alt = recipeDetails.title;
        recipeImage.className = 'img-fluid';
        recipeImage.style.display = 'block';
        recipeImage.style.margin = 'auto';
        recipeImage.style.marginBottom = '1vh';
        recipeImage.style.marginTop = '1vh';
        recipeBody.appendChild(recipeImage);

        const recipeSummary = document.createElement('p');
        recipeSummary.style.textAlign = 'justify';
        recipeSummary.style.marginBottom = '1vh';
        recipeSummary.style.fontSize = '1.8vh';
        recipeSummary.style.marginRight = '1vw';
        recipeSummary.innerHTML = recipeDetails.summary;
        recipeBody.appendChild(recipeSummary);

        if(recipeDetails.healthScore) {
            const healthScoreElement = document.createElement('p');
            healthScoreElement.textContent = `Health Score: ${recipeDetails.healthScore}`;
            recipeBody.appendChild(healthScoreElement);
        }

        if(recipeDetails.diets.length > 0) {
            const dietElement = document.createElement('p');
            dietElement.textContent = `Suitable for: ${recipeDetails.diets.join(', ')}`;
            modalBody.appendChild(dietElement);
        }

        const recipeSourceButton = document.createElement('a');
        recipeSourceButton.href = recipeDetails.sourceUrl;
        recipeSourceButton.target = '_blank';
        recipeSourceButton.textContent = 'View Recipe Source';
        recipeSourceButton.className = 'btn btn-primary';
        modalBody.appendChild(recipeSourceButton);

        $('#recipeModal').modal('show');
    }

    document.getElementById('startScan').addEventListener('click', function() {
        //Change the input method to barcode
        document.getElementById('inputMethod').value = 'barcode';
        // Show the scanner container
        document.getElementById('scanner-container').style.display = 'block';

        Quagga.init({
            inputStream: {
                type: "LiveStream",
                constraints: {
                    facingMode: "environment" // use the rear camera
                },
                target: document.querySelector('#scanner-container') // Pass the DOM element of your choice
            },
            decoder: {
                readers: ["ean_reader", "upc_reader", "upc_e_reader"] // including EAN, UPC-A, and UPC-E readers
            }
        }, function(err) {
            if (err) {
                console.log(err);
                alert('Error starting the scanner.');
                return;
            }
            Quagga.start();
        });

        Quagga.onDetected(function(result) {
            Quagga.stop(); // stop scanning once a barcode is detected

            const barcode = result.codeResult.code;
            document.getElementById('inputField').value = barcode; // populate the input field

            //Add item by clicking the add item button
            document.getElementById('addItemButton').click();

            // Hide the scanner container
            document.getElementById('scanner-container').style.display = 'none';
        });
    });




    //every few seconds, update the inventory
    setInterval(async () => {
        await fetchAndDisplayInventory();
    }, 5000);
</script>



</body>

</html>
